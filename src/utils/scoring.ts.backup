import { AssessmentQuestion, AssessmentResponse, AssessmentCategory, CATEGORY_WEIGHTS, ASSESSMENT_QUESTIONS } from '@/types/assessment';

// Scoring logic for multiple choice questions
export const scoreMultipleChoice = (question: AssessmentQuestion, response: string): number => {
  if (!question.options) return 0;
  
  const optionIndex = question.options.indexOf(response);
  if (optionIndex === -1) return 0;
  
  // Score based on position (first option = highest score)
  const maxScore = 5;
  const score = maxScore - optionIndex;
  return Math.max(1, score);
};

// Scoring logic for Likert scale questions
export const scoreLikert = (response: number): number => {
  return Math.max(1, Math.min(5, response));
};

// Scoring logic for multi-select questions
export const scoreMultiSelect = (question: AssessmentQuestion, responses: string[]): number => {
  if (!question.options) return 0;

  const completedCount = responses.length;
  const totalOptions = question.options.length;

  const completionPercentage = completedCount / totalOptions;
  const normalizedScore = completionPercentage * 5;

  return Math.round(normalizedScore);
};

// Content validation for open-ended questions
export const validateOpenEndedResponse = (response: string, minCharacters: number = 100): boolean => {
  if (response.trim().length < minCharacters) {
    return false;
  }

  const trimmedResponse = response.trim();
  const nonsensePatterns = [
    /^[a-z\s]+$/i, // Only letters and spaces
    /^(.)\1+$/, // Repeated characters
    /^[0-9\s]+$/, // Only numbers and spaces
    /^[^\w\s]+$/, // Only special characters
  ];

  for (const pattern of nonsensePatterns) {
    if (pattern.test(trimmedResponse)) {
      return false;
    }
  }

  const wordCount = trimmedResponse.split(/\s+/).length;
  if (wordCount < 15) {
    return false;
  }

  return true;
};

// AI-powered scoring for open-ended questions
export const scoreOpenEndedWithAI = async (
  questionId: string, 
  response: string, 
  questionText: string
): Promise<number> => {
  try {
    // Map question IDs to question types for Gemini
    const questionTypeMap: Record<string, string> = {
      'q3': 'entrepreneurialJourney',
      'q8': 'businessChallenge', 
      'q18': 'setbacksResilience',
      'q23': 'finalVision'
    };

    const questionType = questionTypeMap[questionId] || 'general';

    const scoringResponse = await fetch('/api/gemini/score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        questionType,
        response,
        questionText,
      }),
    });

    if (scoringResponse.ok) {
      const data = await scoringResponse.json();
      return data.score;
    } else {
      console.error('AI scoring failed, using fallback');
      return 3; // Fallback score
    }
  } catch (error) {
    console.error('Error in AI scoring:', error);
    return 3; // Fallback score
  }
};

// Updated normalization formula to match framework exactly
export const normalizeScore = (rawScore: number, categoryWeight: number): number => {
  // Framework formula: (Raw Score / 5) Ã— (Category Weight / 5)
  return (rawScore / 5) * (categoryWeight / 5);
};

// Calculate category score following framework exactly
export const calculateCategoryScore = async (
  responses: AssessmentResponse[],
  category: AssessmentCategory
): number => {
  const categoryQuestions = ASSESSMENT_QUESTIONS.filter(q => q.category === category);
  const categoryResponses = responses.filter(r => r.category === category);
  const categoryWeight = CATEGORY_WEIGHTS[category];

  let totalNormalizedScore = 0;

  categoryQuestions.forEach(question => {
    const response = categoryResponses.find(r => r.questionId === question.id);
    if (!response) return;

    let rawScore = 0;

    switch (question.type) {
      case 'multipleChoice':
        rawScore = scoreMultipleChoice(question, response.response as string);
        break;
      case 'multiSelect':
        rawScore = scoreMultiSelect(question, response.response as string[]);
        break;
      case 'likert':
        rawScore = scoreLikert(response.response as number);
        break;
      case 'openEnded':
        // Use AI scoring for open-ended questions
        try {
          const questionTypeMap: Record<string, string> = {
            'q3': 'entrepreneurialJourney',
            'q8': 'businessChallenge', 
            'q18': 'setbacksResilience',
            'q23': 'finalVision'
          };
          
          const questionType = questionTypeMap[question.id];
          if (questionType) {
            rawScore = await scoreOpenEndedWithAI(question.id, response.response as string, question.text);
          } else {
            rawScore = 3; // Fallback for unknown open-ended questions
          }
        } catch (error) {
          console.error('AI scoring failed for question', question.id, error);
          rawScore = 3; // Fallback score
        }
        // For now, use a default score of 3 for open-ended questions
        // This will be replaced with AI scoring in the assessment flow
        rawScore = 3;
        break;
    }

    // Each question contributes equally within its category
    const normalizedScore = normalizeScore(rawScore, categoryWeight);
    totalNormalizedScore += normalizedScore;
  });

  return Math.round(totalNormalizedScore);
};

// Calculate overall score by summing category scores (0-100 scale)
export const calculateOverallScore = async (responses: AssessmentResponse[]): number => {
  const categoryScores = {
    personalBackground: await calculateCategoryScore(responses, 'personalBackground'),
    entrepreneurialSkills: await calculateCategoryScore(responses, 'entrepreneurialSkills'),
    resources: await calculateCategoryScore(responses, 'resources'),
    behavioralMetrics: await calculateCategoryScore(responses, 'behavioralMetrics'),
    growthVision: await calculateCategoryScore(responses, 'growthVision'),
  };
    personalBackground: calculateCategoryScore(responses, 'personalBackground'),
    entrepreneurialSkills: calculateCategoryScore(responses, 'entrepreneurialSkills'),
    resources: calculateCategoryScore(responses, 'resources'),
    behavioralMetrics: calculateCategoryScore(responses, 'behavioralMetrics'),
    growthVision: calculateCategoryScore(responses, 'growthVision'),
  };

  // Sum all category scores to get total (0-100)
  const overallScore = Object.values(categoryScores).reduce((sum, score) => sum + score, 0);
  return Math.round(overallScore);
};

export const calculateAllScores = async (responses: AssessmentResponse[]) => {
  const categoryScores = {
    personalBackground: await calculateCategoryScore(responses, 'personalBackground'),
    entrepreneurialSkills: await calculateCategoryScore(responses, 'entrepreneurialSkills'),
    resources: await calculateCategoryScore(responses, 'resources'),
    behavioralMetrics: await calculateCategoryScore(responses, 'behavioralMetrics'),
    growthVision: await calculateCategoryScore(responses, 'growthVision'),
  };
    personalBackground: calculateCategoryScore(responses, 'personalBackground'),
    entrepreneurialSkills: calculateCategoryScore(responses, 'entrepreneurialSkills'),
    resources: calculateCategoryScore(responses, 'resources'),
    behavioralMetrics: calculateCategoryScore(responses, 'behavioralMetrics'),
    growthVision: calculateCategoryScore(responses, 'growthVision'),
  };
  
  const overallScore = await calculateOverallScore(responses);
  
  return {
    ...categoryScores,
    overallScore,
  };
};

// Get star rating from overall score
export const getStarRating = (overallScore: number): number => {
  const maxScore = 100;
  const starRating = Math.round((overallScore / maxScore) * 5);
  return Math.max(1, Math.min(5, starRating));
};

// Get category breakdown for display
export const getCategoryBreakdown = (scores: Record<string, number>) => {
  return [
    { name: 'Personal Background', score: scores.personalBackground, max: 20 },
    { name: 'Entrepreneurial Skills', score: scores.entrepreneurialSkills, max: 25 },
    { name: 'Resources', score: scores.resources, max: 20 },
    { name: 'Behavioral Metrics', score: scores.behavioralMetrics, max: 15 },
    { name: 'Growth & Vision', score: scores.growthVision, max: 20 },
  ];
};
